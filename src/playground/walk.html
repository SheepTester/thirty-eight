<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Walk</title>
    <meta name="description" content="Arrow keys to walk, perhaps?"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <script src="/sheep3.js" charset="utf-8"></script>
    <style>
      @import url('../css/basic.css');
      @import url('../css/canvas.css');

      body {
        background-color: grey;
      }
    </style>
  </head>
  <body>
    <script type="module">
import { CanvasWrapper, loadImage } from '../lib/canvas.js'
import { SpritesheetAnimation } from '../lib/spritesheet-animation.js'
import { Resizer } from '../lib/resizer.js'
import { Animator } from '../lib/animator.js'
import { Simulator } from '../lib/simulator.js'
import { Walkway } from '../lib/walkway.js'
import { Keys } from '../lib/keys.js'

const FPS = 6
const PX_PER_WALK_CYCLE = 18
const FRAMES_PER_WALK_CYCLE = 6

async function main () {
  const canvas = new CanvasWrapper().addTo(document.body)
  const resizer = new Resizer([canvas]).listen()
  const { keys } = new Keys().listen()
  const [sheepStillImage, sheepWalkImage, walkwayImage] = await Promise.all([
    loadImage('../assets/sheep3.png'),
    loadImage('../assets/sheep-walk.png'),
    loadImage('../assets/metal-walkway.png'),
    resizer.resize()
  ])
  const walkway = new Walkway({ image: walkwayImage })
  const sheepStill = new SpritesheetAnimation({ image: sheepStillImage, fps: FPS, frames: 3 })
  const sheepWalk = new SpritesheetAnimation({ image: sheepWalkImage, fps: FPS, frames: 8 })
  const minX = -300
  const maxX = 300
  const scale = 3
  const acceleration = 20 // px/s^2
  const maxSpeed = 150
  let speed = 40 // px/s
  let cameraX = 0
  let x = 0
  let walkInitX
  let walkChangeTime
  let visualX
  let walking = false
  let direction
  function simulate (elapsedTime, totalTime) {
    if (keys.has('ArrowLeft') !== keys.has('ArrowRight')) {
      if (!walking) {
        walking = true
        walkChangeTime = totalTime
        walkInitX = x
        speed = 40
      }
      if (speed < maxSpeed) {
        speed += acceleration * elapsedTime
        if (speed > maxSpeed) speed = maxSpeed
      }
      if (keys.has('ArrowLeft')) {
        x -= speed * elapsedTime
        direction = 'left'
      }
      if (keys.has('ArrowRight')) {
        x += speed * elapsedTime
        direction = 'right'
      }
      if (x < minX) x = minX
      if (x > maxX) x = maxX
      const walkFrame = Math.floor(Math.abs(x - walkInitX) / PX_PER_WALK_CYCLE * FRAMES_PER_WALK_CYCLE)
      sheepWalk.frame = walkFrame % FRAMES_PER_WALK_CYCLE + 1
      visualX = walkInitX + Math.floor(Math.abs(x - walkInitX) / PX_PER_WALK_CYCLE) * PX_PER_WALK_CYCLE * Math.sign(x - walkInitX)
    } else if (walking) {
      walking = false
    }
    cameraX += (x * scale - cameraX) * 1e-40 ** elapsedTime
  }
  const simulator = new Simulator({ simulations: [{ simulate }, sheepStill] })
  const animator = new Animator(() => {
    simulator.simulate()
    canvas.context.clearRect(0, 0, canvas.width, canvas.height)
    canvas.context.imageSmoothingEnabled = false

    const shiftX = canvas.width / 2 - cameraX
    if (walking) {
      if (direction === 'left') {
        canvas.context.save()
        canvas.context.scale(-1, 1)
        sheepWalk.draw({
          canvas,
          x: -(visualX + sheepStill.width / 2) * scale - shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepWalk.height) * scale,
          width: sheepWalk.width * scale,
          height: sheepWalk.height * scale
        })
        canvas.context.restore()
      } else {
        sheepWalk.draw({
          canvas,
          x: (visualX - sheepStill.width / 2) * scale + shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepWalk.height) * scale,
          width: sheepWalk.width * scale,
          height: sheepWalk.height * scale
        })
      }
    } else {
      if (direction === 'left') {
        canvas.context.save()
        canvas.context.scale(-1, 1)
        sheepStill.draw({
          canvas,
          x: -(x + sheepStill.width / 2) * scale - shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepStill.height) * scale,
          width: sheepStill.width * scale,
          height: sheepStill.height * scale
        })
        canvas.context.restore()
      } else {
        sheepStill.draw({
          canvas,
          x: (x - sheepStill.width / 2) * scale + shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepStill.height) * scale,
          width: sheepStill.width * scale,
          height: sheepStill.height * scale
        })
      }
    }
    walkway.draw({
      canvas,
      start: (minX - sheepStill.width / 2) * scale + shiftX,
      end: (maxX + sheepStill.width / 2) * scale + shiftX,
      y: canvas.height / 2,
      height: walkwayImage.height * scale
    })
  }).start()
}

main()
    </script>
  </body>
</html>
