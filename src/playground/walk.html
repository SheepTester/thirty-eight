<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Walk</title>
    <meta name="description" content="Arrow keys to walk, perhaps?"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="/sheep3.css">
    <script src="/sheep3.js" charset="utf-8"></script>
    <style>
      @import url('../css/basic.css');
      @import url('../css/canvas.css');
      @import url('../css/dialogue.css');

      body {
        background-color: grey;
      }

      .dialogue-text {
        animation: loop 10s infinite;
      }
      @keyframes loop {
        0% {
          top: 0;
        }
        18% {
          top: 0;
        }
        20% {
          top: -4em;
        }
        38% {
          top: -4em;
        }
        40% {
          top: -8em;
        }
        58% {
          top: -8em;
        }
        60% {
          top: -12em;
        }
        78% {
          top: -12em;
        }
        80% {
          top: -16em;
        }
        98% {
          top: -16em;
        }
        100% {
          top: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="dialogue">
      <h2 class="speaker-name sans-nouveaux">82300029</h2>
      <div class="dialogue-body">
        <img src="../assets/sheep2.png" class="speaker-image pixelated">
        <div class="dialogue-text-wrapper">
          <p class="dialogue-text sans-nouveaux">Nonetheless, due to strict guidelines set by the Department of Ovine English Terms, because the archive itself is considered an ovine work, its name must preserve its casing, spelling, specific Unicode codepoints, and bold/italic formatting. Thus, this site will aim to respect these terms and hopes others will too. Please note that the first two quotation marks and the apostrophe are ambidextrous, while the third quotation mark is an opening/left double quotation mark.</p>
        </div>
      </div>
    </div>
    <script type="module">
import { CanvasWrapper, loadImage } from '../lib/canvas.js'
import { SpritesheetAnimation } from '../lib/spritesheet-animation.js'
import { Resizer } from '../lib/resizer.js'
import { Animator } from '../lib/animator.js'
import { Simulator } from '../lib/simulator.js'
import { Walkway } from '../lib/walkway.js'
import { Keys } from '../lib/keys.js'

const FPS = 6
const PX_PER_WALK_CYCLE = 18
const FRAMES_PER_WALK_CYCLE = 6

async function main () {
  const canvas = new CanvasWrapper().addTo(document.body)
  const resizer = new Resizer([canvas]).listen()
  const { keys } = new Keys().listen()
  const [sheepStillImage, sheepWalkImage, walkwayImage] = await Promise.all([
    loadImage('../assets/sheep3.png'),
    loadImage('../assets/sheep-walk.png'),
    loadImage('../assets/metal-walkway.png'),
    resizer.resize()
  ])
  const walkway = new Walkway({ image: walkwayImage })
  const sheepStill = new SpritesheetAnimation({ image: sheepStillImage, fps: FPS, frames: 3 })
  const sheepWalk = new SpritesheetAnimation({ image: sheepWalkImage, fps: FPS, frames: 8 })
  const minX = -300
  const maxX = 300
  const scale = 3
  const speed = 40 // px/s
  let cameraX = 0
  let x = 0
  let walkInitX
  let walkChangeTime
  let visualX
  let walking = false
  let direction
  function simulate (elapsedTime, totalTime) {
    if (keys.has('ArrowLeft') !== keys.has('ArrowRight')) {
      if (!walking) {
        walking = true
        walkChangeTime = totalTime
        walkInitX = x
      }
      if (keys.has('ArrowLeft')) {
        x -= speed * elapsedTime
        direction = 'left'
      }
      if (keys.has('ArrowRight')) {
        x += speed * elapsedTime
        direction = 'right'
      }
      if (x < minX) x = minX
      if (x > maxX) x = maxX
      const walkFrame = Math.floor(Math.abs(x - walkInitX) / PX_PER_WALK_CYCLE * FRAMES_PER_WALK_CYCLE)
      sheepWalk.frame = walkFrame % FRAMES_PER_WALK_CYCLE + 1
      visualX = walkInitX + Math.floor(Math.abs(x - walkInitX) / PX_PER_WALK_CYCLE) * PX_PER_WALK_CYCLE * Math.sign(x - walkInitX)
    } else if (walking) {
      walking = false
    }
    cameraX += (x * scale - cameraX) * 1e-40 ** elapsedTime
  }
  const simulator = new Simulator({ simulations: [{ simulate }, sheepStill] })
  const animator = new Animator(() => {
    simulator.simulate()
    canvas.context.clearRect(0, 0, canvas.width, canvas.height)
    canvas.context.imageSmoothingEnabled = false

    const shiftX = canvas.width / 2 - cameraX
    if (walking) {
      if (direction === 'left') {
        canvas.context.save()
        canvas.context.scale(-1, 1)
        sheepWalk.draw({
          canvas,
          x: -(visualX + sheepStill.width / 2) * scale - shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepWalk.height) * scale,
          width: sheepWalk.width * scale,
          height: sheepWalk.height * scale
        })
        canvas.context.restore()
      } else {
        sheepWalk.draw({
          canvas,
          x: (visualX - sheepStill.width / 2) * scale + shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepWalk.height) * scale,
          width: sheepWalk.width * scale,
          height: sheepWalk.height * scale
        })
      }
    } else {
      if (direction === 'left') {
        canvas.context.save()
        canvas.context.scale(-1, 1)
        sheepStill.draw({
          canvas,
          x: -(x + sheepStill.width / 2) * scale - shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepStill.height) * scale,
          width: sheepStill.width * scale,
          height: sheepStill.height * scale
        })
        canvas.context.restore()
      } else {
        sheepStill.draw({
          canvas,
          x: (x - sheepStill.width / 2) * scale + shiftX,
          y: canvas.height / 2 + (walkwayImage.height - sheepStill.height) * scale,
          width: sheepStill.width * scale,
          height: sheepStill.height * scale
        })
      }
    }
    walkway.draw({
      canvas,
      start: (minX - sheepStill.width / 2) * scale + shiftX,
      end: (maxX + sheepStill.width / 2) * scale + shiftX,
      y: canvas.height / 2,
      height: walkwayImage.height * scale
    })
  }).start()
}

main()
    </script>
  </body>
</html>
